inp w ----------------------------- 1
mul x 0
add x z
mod x 26
div z 1
add x 11
eql x w => x = 0
eql x 0 => x = 1
mul y 0 => y = 0
add y 25 => y = 25
mul y x => y = 25
add y 1 => y = 26
mul z y => z = 0
mul y 0  => y = 0da
add y w  => y = INPUT
add y 6 => y = input + 6
mul y x  => y = input + 6 ( si x = 1)
add z y => z = input + 6
inp w  ----------------------------- 2
mul x 0 => x = 0
add x z => x = z
mod x 26 => mod de Z -> if z = 26 ! impossible, x = z
div z 1 => sert a rien
add x 13 => z + 13
eql x w  => x = 0 ( impossible x = q)
eql x 0 => x = 1 ( car x =0)
mul y 0  => y = 0
add y 25 => y = 25
mul y x => y = 25 ( y * 1)
add y 1 => y = 26
mul z y => z = z * y ! ( = 26 * (input+6)) = multiple de 26 !
mul y 0  => y = 0
add y w => y = w ( input2 )
add y 14  => y = input2 + 14
mul y x    => y = input2 + 14 ( x = 1)
add z y => z = z1  + (input2 +14) ( z1 = 26*(input1+6) )
inp w  ----------------------------- 3
mul x 0 => x = 0
add x z => x = z
mod x 26 x = reste de` z, if z = 26, x = 0, x = 14 ( z = 26k + input2+14) -> reste = input2 +14 / input1 is irrelevant
div z 1 -> useless
add x 15 x = 15 + reste
eql x w => x = 0
eql x 0 => x = 1
mul y 0 => y = 0
add y 25 => y = 25 
mul y x => y = 25 
add y 1 => y = 26
mul z y => z = 26k k =z / z = 26 * (z1  + (input2 +14) )
mul y 0 => y = 0
add y w => y = input3
add y 14 => y = input3 + 14
mul y x  => y = input3 + 14
add z y  => z 

inp w ----------------------------- 4
mul x 0 => x = 0 
add x z => x = z
mod x 26 => x = reste de z, given that z is a multple of 26
div z 26 z = 26k + input3 + 14. => divisé par 26 = k ( go back to previous z)
add x - 8 => x - 8 ( x possible négatif ?) -> nul si PREVIOUS = 3 and HERE = 9
eql x w => 0/1
eql x 0 => 0/1
mul y 0
add y 25 `
mul y x => x =0 => y =0
add y 1 => y = 1
mul z y => z = z
mul y 0 -> 0
add y w -> input5
add y 10 -> input5 + 10
mul y x -> 0 
add z y -> add 0
inp w ----------------------------- 5
mul x 0
add x z
mod x 26
div z 1
add x 13 
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 9
mul y x
add z y
inp w ----------------------------- 6
mul x 0
add x z
mod x 26
div z 1
add x 15
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 12
mul y x
add z y
inp w ----------------------------- 7
mul x 0
add x z
mod x 26
div z 26 -> go back one step
add x -11 -> possible x 0
eql x w -> 0
eql x 0 -> 0
mul y 0
add y 25
mul y x -> y = 0 
add y 1 -> y =1
mul z y -> z = z
mul y 0 => 0
add y w => y = input
add y 8 => y = input +8
mul y x => y x x = 0
add z y => z = z
inp w ------------------------ 8
mul x 0
add x z
mod x 26
div z 26 osef ? (?) = 0 if z < 26 ! go back one step
add x -4 -> si 0 
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 13
mul y x
add z y
inp w ------------------------ 9
mul x 0
add x z
mod x 26
div z 26 -> go back one step
add x -15 -> 0 !
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 12
mul y x
add z y
inp w ------------------------ 10
mul x 0
add x z
mod x 26
div z 1
add x 14
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 6
mul y x
add z y
inp w -------------------- 11
mul x 0
add x z
mod x 26
div z 1
add x 14
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 9
mul y x
add z y
inp w ---------------------- 12
mul x 0
add x z
mod x 26
div z 26 osef ? (?) = 0 if z < 26 ! go back one step
add x -1 -> poss 0 !
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 15
mul y x
add z y
inp w ----------------------------- 13
mul x 0 => x = 0
add x z => x = z
mod x 26 => x = reste de mod 26
div z 26 => osef ? (?) = 0 if z < 26 !
add x -8 => reste de mod 26 - 8 -> poss 0 !
eql x w => 1/0
eql x 0  =>  1/0
mul y 0 => y = 0 
add y 25 => y = 25
mul y x => y = y ou y = 0
add y 1 => y + 1
mul z y = z * y / ( z = whatever)
mul y 0 => y = 0
add y w => y = input
add y 4 => y = input + 4
mul y x => y * x (x = 0/1)
add z y => z + y
inp w --------------------------------- 14
mul x 0 x => 0
add x z x => x = z
mod x 26 x => x = reste de mod26 
div z 26 => osef ? (?) = 0 if z < 26 !
add x -14 => reste de mod26(z) - 14 -> poss 0 !
eql x w => x = 0 if x = input
eql x 0 => x = 0 if x = input sinon c'est 1
mul y 0 => y = 0
add y 25 => y = 25
mul y x => y = 0 if x = 0
add y 1 => y = 1
mul z y => z * y
mul y 0 => y = 0
add y w => y = y + input
add y 10 => y = y +10 
mul y x => y * x -> si x = 0, z y = 0
add z y => z + y